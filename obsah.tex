\chapter{Introduction}
In last few decades importance of computers in our everyday lifes has laregly increased.
A lot of us can only hardly imagine doing their jobs without help of appropriate computer program
and we also spend a plenty of time using computers (e.g. personal computers or mobile devices) in leisure time.
There is also wide usage of computers in more critical applications like autopilot in an aeroplane
or programs for controlling power stations.
But growing number of applications of computer programs brings also need for their safety and security.

However, guarantee of software quality and correctness is not easy task
because programs has often many state which they go through during computation
and it could be very time and (memory) space demanding to check whether no undesirable thing
happens in any of the visited states.
One approach to ensure software qaulity is \emph{testing} (and dynamic analysis) which is basically based
on runnig a program in the different contexts and under the different inputs
and checking whether programs behaviour and outputs are expected one.
This method can satisfy many of requiremnts for software quality and often cover greate space of programs behaviours
but on the other side it is only possbile to prove presence of the errors using testing not their absence (\cite{djikstra}).
Moreover finding errors during testing does not mean that all of them has been found.

The mentioned weakness of testing can be resolved by \emph{formal verification}
which is another approach to checking program correctness.
Formal verification is method for checking whether a given system meets a given specification \cite{fav:lecture}.
There are three main branches of formal verification.
The first one is \emph{model checking} which systematically explores of a model (e.g. model of a program) to
prove that a property holds along the whole model.
The second approach is static analysis which is done over a source code (or some modification of it) of a system
without its explicit execution.
The last one is \emph{theorem proving}.
It proves the program in standard mathematical way -- starting from axioms and proving theorems to
verify the properties of a given system.
Theorem proving could be more or less automated.

This thesis deals with specific part of static analysis called shape analysis which is focused to verification of the programs manipulating
complex data structures (like a different kinds of lists and trees) allocated on the heap.
The properties checked for this class of programs are for example checking whether no dangling
pointers are dereferenced (no invalid dereference), whether all allocated memory on a heap is also freed (no memory leaks)
a program exuction or whether there is not dealocated pointer which has not have assigned memory (no invalid free).
There are different approaches to this kind of static analysis with the different advantages.
For example approach based on \emph{seperation logic} brings scalability to a verification procedure.
On the other side, automata based approach, conceretly \emph{abstract tree regular model checking}, is
superior in flexibility.
However, this theisis will be focused to a verification procedure employing concept of Forest automata (FA) which tries
to synthetize benefits of the mentioned approaches.

Forest automata has been introduce in \cite{forester} and they are extension of finite automata or more precisly finite tree automata.
They are used as abstract domain in this verification procedure.
Basically, the verification procudere based on FA is perforing symbolic execution of a verified program and
FA serves here as the abstract domain.
A prototype of this verification procedure has been implemented in tool called \emph{Forester}.
Forester verifies programs in language C and it can detect invalid dereferences, invalid free, memory leaks and also reachability of an error label.
It is yet able to verify non-trivial data structures like skiplist of the second and the third level
but there is still room for improvement, e.g. by extending support of C language.

The main topic of this topic is improvement of Forester tool.
Since FA are highly related to finite tree automata (TA) the first of goal is to connect
Forester with VATA library -- state-of-the-art library for TA manipulation.
Particulary, this consists creating of an interface between Forester and VATA to employ VATA as TA library for Forester backend.
The second goal of this thesis is to implement \emph{backward run} for Forester what enables checking spuriousness of an error found in program.
The error could be spurous because of used to high abstraction over FA domain but the information get by backward could be used for refinment of \emph{predicate abstraction}
what is one kind of abstraction used in Forester (another one is \emph{height abstraction}.
It was also not possible to fully test predicate abstraction because of absence of backward run implementation
so a part of this goal is to complete and test implementation of predicate abstraction.

A structure of this theisi will be following.
In Chapter \ref{ch:prel} will be given definitions of preliminaries for further text.
Chapter \ref{ch:tools} provides description of VATA library and Forester tool.
General principle of backward run and predicate abstract is given in Chapter \label{ch:pred} and their
application for verification based on FA is described in Chapter \label{ch:backwar}.
Chapter \ref{ch:impl} provides description of implementation and finally Chapter \ref{ch:eval} is about evalutation.
\cite{Knuth}

\chapter{Preliminaries}
\label{ch:prel}

\section{Graphs and Languages}
\section{Tree Automata}
\section{Forest Automata}

\chapter{VATA and Forester}
\label{ch:tools}

\section{VATA}

\section{Forester}

\section{Other Tools}

\chapter{??Predicate Abstraction and Backward Run??}
\label{ch:pred}

\chapter{Backward Run in Forest Automata Based Verification}
\label{ch:backward}

\section{Backward Run over Symbolic Context}

\section{Intersection of Forest Automata}

\chapter{Implementation}
\label{ch:impl}

\section{Execution Trace}
\section{Module For Intersection}

\chapter{Evaluation}
\label{ch:eval}

\chapter{Conclusion}
\label{ch:concl}
