\chapter{Introduction}
In last few decades importance of computers in our everyday lifes has laregly increased.
A lot of us can only hardly imagine doing their jobs without help of appropriate computer program
and we also spend a plenty of time using computers (e.g. personal computers or mobile devices) in leisure time.
There is also wide usage of computers in more critical applications like autopilot in an aeroplane
or programs for controlling power stations.
But growing number of applications of computer programs brings also need for their safety and security.

However, guarantee of software quality and correctness is not easy task
because programs has often many state which they go through during computation
and it could be very time and (memory) space demanding to check whether no undesirable thing
happens in any of the visited states.
One approach to ensure software qaulity is \emph{testing} (and dynamic analysis) which is basically based
on runnig a program in the different contexts and under the different inputs
and checking whether programs behaviour and outputs are expected one.
This method can satisfy many of requiremnts for software quality and often cover greate space of programs behaviours
but on the other side it is only possbile to prove presence of the errors using testing not their absence (\cite{djikstra}).
Moreover finding errors during testing does not mean that all of them has been found.

The mentioned weakness of testing can be resolved by \emph{formal verification}
which is another approach to checking program correctness.
Formal verification is method for checking whether a given system meets a given specification \cite{fav:lecture}.
There are three main branches of formal verification.
The first one is \emph{model checking} which systematically explores of a model (e.g. model of a program) to
prove that a property holds along the whole model.
The second approach is static analysis which is done over a source code (or some modification of it) of a system
without its explicit execution.
The last one is \emph{theorem proving}.
It proves the program in standard mathematical way -- starting from axioms and proving theorems to
verify the properties of a given system.
Theorem proving could be more or less automated.

This thesis deals with specific part of static analysis called shape analysis which is focused to verification of the programs manipulating
complex data structures (like a different kinds of lists and trees) allocated on the heap.
The properties checked for this class of programs are for example checking whether no dangling
pointers are dereferenced (no invalid dereference), whether all allocated memory on a heap is also freed (no memory leaks)
a program exuction or whether there is not dealocated pointer which has not have assigned memory (no invalid free).
There are different approaches to this kind of static analysis with the different advantages.
For example approach based on \emph{seperation logic} brings scalability to a verification procedure.
On the other side, automata based approach, conceretly \emph{abstract tree regular model checking}, is
superior in flexibility.
However, this theisis will be focused to a verification procedure employing concept of Forest automata (FA) which tries
to synthetize benefits of the mentioned approaches.

Forest automata has been introduce in \cite{forester} and they are extension of finite automata or more precisly finite tree automata.
They are used as abstract domain in this verification procedure.
Basically, the verification procudere based on FA is perforing symbolic execution of a verified program and
FA serves here as the abstract domain.
A prototype of this verification procedure has been implemented in tool called \emph{Forester}.
Forester verifies programs in language C and it can detect invalid dereferences, invalid free, memory leaks and also reachability of an error label.
It is yet able to verify non-trivial data structures like skiplist of the second and the third level
but there is still room for improvement, e.g. by extending support of C language.

The main topic of this topic is improvement of Forester tool.
Since FA are highly related to finite tree automata (TA) the first of goal is to connect
Forester with VATA library -- state-of-the-art library for TA manipulation \cite{tacas12}.
Particulary, this consists creating of an interface between Forester and VATA to employ VATA as TA library for Forester backend.
The second goal of this thesis is to implement \emph{backward run} for Forester what enables checking spuriousness of an error found in program.
The error could be spurous because of used to high abstraction over FA domain but the information get by backward could be used for refinment of \emph{predicate abstraction}
what is one kind of abstraction used in Forester (another one is \emph{height abstraction}.
It was also not possible to fully test predicate abstraction because of absence of backward run implementation
so a part of this goal is to complete and test implementation of predicate abstraction.

A structure of this theisi will be following.
In Chapter \ref{ch:prel} will be given definitions of preliminaries for further text.
Chapter \ref{ch:tools} provides description of VATA library and Forester tool.
General principle of backward run and predicate abstract is given in Chapter \label{ch:pred} and their
application for verification based on FA is described in Chapter \label{ch:backwar}.
Chapter \ref{ch:impl} provides description of implementation and finally Chapter \ref{ch:eval} is about evalutation.
\cite{Knuth}

\chapter{Preliminaries}
\label{ch:prel}

\section{Graphs and Languages}
\section{Tree Automata}
\section{Forest Automata}

\chapter{Forest Automata based Verification}

\chapter{\vata\ and The Forester tool}
\label{ch:tools}

As it was mentioned in introduction, FA based verification is implemented by tool
called Forester.
Since the FA are closely related to TA as it was shown in Chapter \ref{ch:prel}
Forester also depends on an implementation of TA.
It currently has its own implementation of TA providing operations over TA needed during verification procedure.
However it is quite impratical to mantain a special TA library inside of Forester
epsecially when we consider that there is a highly efficient TA library called VATA.
The VATA library provides implementation of standard operations over TA like union or intersection
but it also implements state-of-the-art algorithms \cite{tacas11} for language inclusion checking which efficieny
is also crucial for performance of Forester.
It seems locigcal according to these facts to connect Forester with the VATA library employing VATA like a backend TA library for Forester.

This chapter will provide a description of the VATA library firstly and then also a description of the Forester tool.
Finally the implementation of the Forester tool using VATA library done as a part of this thesis will be described.

\section{\vata\ }
\label{sec:VATA}

\vata\ is open source library for nondeterministic tree automata.
Its main application is in the field of formal verification.
VATA is licensed under GPL, version 3, and can be obtained from its official website \cite{www:vata}.
Implentation programming language is C++.
It is the only library to our knowledge implementing state-of-the algorithms for checking inclusion of NTA languages
what makes it suitable for usage as a Forester backend library.
However, \vata\ does not only provide implementation of algorithms for NTA but also highly efficient implementation of
algorithms for nondeterministic finite automata \cite{hruska13}.

\subsection{Design}
\vata\ currently provides methods for representation of NTA in explicit encoding and also in semi-symbolic (top-down and bottom-up)
encoding using \emph{MTBDD} but it has been designed to be easy extended by other encodings (for others automata).
The library provides both API for creating and manipulating NTA to other programs and also command line interface (cli) build around
the API for experimenting with tree automata in text format directly from command line.
The main idea of the design of the library is given in Figure \ref{fig:vata}.
As you can see there are the three main parts in the library design:
\begin{enumerate}
	\item \emph{Parsers} -- Parsing an input automaton from a text file.
		Timbuk \cite{timbuk} is currently the only one supported format for parsing input automata.
	\item \emph{Serializers} -- Serializing an automaton to a text file.
		Timbuk format is again the only one supported format.
	\item \emph{Automata encodings} -- The particular encodings of NTA.
		An encoding should consists of core module implementing of NTA representation itself
		and also the operations over NTA in this encoding.
\end{enumerate}

\begin{figure}[bt]
\begin{center}
\input{fig/lib_design.tikz}
		\caption{The main concept of \vata. Figure is taken from \cite{tacas12}}.
		\label{fig:vata}
\end{center}
\end{figure}

A \emph{program} (e.g. cli of VATA is such a program) employing the three parts of \vata\ could works as follows.
An input automaton is loaded by one of the parsers to an intermediate representation.
The wrapping program chooses internal encoding of NTA to which is automaton stored from intermediate encoding (please note that it is also
create automaton in the chosen enconding directly using API provided by VATA).
Then the automaton is processed and the applied operations are implemented by module of the chosen encoding.
Finally, automaton could be serialized to an output format.
When one wants to add her own encoding then she needs to implement only core of encoding (with API for creating automaton itself)
and ofcourse needed operations and can employ already implemented parses and serializers of \vata.

\subsection{Implemented NTA encodings}

Using \emph{explicit enconding} NTA transition relation is represented by a hiearchy of the hash tables as it is shown in Figure \ref{fig:explnta}.
The first level of the hash tables hiearchy (\emph{top-level lookup tables}) maps each state $q$ of an automaton to 
a second level of the hash tables hiearchy (\emph{transition cluster}) where are store all symbols which
are presented in a transition where $q$ is at left-handed side.
Each symbol $a$ in a transition cluster is mapped to a pointer to a set in the third level of hiearchy (\emph{sets of pointers to tuples}).
The set contains pointers to tuples which are at right-handed side in a transition with $q$ at left-handed side and with $a$ as a symbol.
The tuples are stored at a special set where every tuples is stored only once.
Please note, that it also possible to share part of transition relation between different automata what
brings higher efficiency in space complexity of implementation.
Module for explicit encoding also stores explicitly set of the final states of a NFA but on
the other side it does not store anywhere explicitly set of states because it can be obtained from a transition relation.

\begin{figure}[bt]
\begin{center}
\input{fig/explicit.tikz}
	\caption{Explicit representation of NTA by \vata. Figure is taken from \cite{tacas12}}.
	\label{fig:explnta}
\end{center}
\end{figure}

\begingroup
\tikzset{every picture/.style={scale=0.8}}%
\begin{figure}[bt]
\label{fig:symnta}
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\input{fig/mtbdd_td.tikz}
		\caption{MTBDD Top-down representation of a NTA. Image is taken from \cite{tacas12}.}
		\label{fig:mtbdd_td}
	\end{subfigure}%
	~
	\begin{subfigure}{.5\textwidth}
	\centering
	\input{fig/mtbdd_bu.tikz}
	\caption{MTBDD Bottom-up representation of a NTA. Image is taken from \cite{tacas12}.}
	\label{fig:mtbdd_bu}
	\end{subfigure}%
\end{figure}
\endgroup

Another already implemented encoding is semi-symbolic based on VATA own implementation of MTBDD package.
Because semi-symblic encoding and MTBDD are not in the aim of this thesis the will no be detaily described
but it is possbile to find such kind of description in \cite{lengal10}.
The main idea of semi-symbolic encoding is shown in Figure \ref{fig:symnta}.
First of all it is necessary to distinguish between (a) top-down and (b) bottom-up variants of this encoding.
The first one maps each state $q$ of a NTA using MTBDD to the sets of the tuples of states such that that it is possible
to make transtion from $q$ under a symbol $a$ to a tuple in apropriate set (each set of tuples is dedicated
to one symbol under which it is possible to make transition from $q$ to the tuples in the set).
The former one symetrically maps each n-tuple $(q_1,\ldots,q_n)$ of a NFA using MTBDD to the sets of states
where each set $S$ is dedicated to a symbol $a$ of the NFA and contains states such that there exists a transition
with $(q_1,\ldots,q_n)$ on the right-handed side and symbol $a$ and state from the set $S$ on the left-handed side.
The final state set of a NTA is again represented by explicit set in both variants,
state set is not stored explicitly because one can obtain it from transition relation and
the symbols are encoded in MTBDD.

All of the mentioned encodings currently support efficient language inclusion checking using algorithm
from \cite{tacas10} but this does not hold for other operations because some of them are not implemented yet for specific encoding.
The full enumeration of the supported operations for the particular encodings is given in Table \ref{tab:vataop}.

\input{tab/vataop.tex}

\section{The Forester Tool}
\label{sec:FA}

Forester is open source tool for verification of program manipulation complex dynamic data structures.
It currently supports program in C langauge.
Forester is distributed as a \emph{GCC} plugin under GPL license, version 3, and can be obtained from its official websice \cite{www.:forester}.
Tool is written in C++.

\subsection{Design}

Forester is implemented as a GCC plugin but it does not analyze directly intermediate code of GCC called GIMPLE but is
uses Code Listener infrastructure \cite{codelistnere} to provide fronted over GIMPLE.

Figure \ref{fig:fa_exec} provides high level view of Forester execution. 
Forester starts analysis of a program by translation of intermediate code representation provided by Code Listenter
to its own microcode.
Microcode represents each program statement by one or few instruction which are indeed abstract transformers.
Symbolic execution is then execute over this microcode.
Abstract domain represented by TA as the core part of symbolic state is gradually transformed by abstract transformers
represented by the microcode instructions during the symbolic execution.
When Forester detects an error the symbolic execution is aborted and the analyzed program is determined as incorrect one.
When symbolic execution is over Forester checks whether there is no left garbage (ofcourse, garbage is gradually checked also during the symbolic exection)
and if it is not then a shape invariat has been found and the analyzed program is determined as correct.

\begin{figure}[bt]
	\begin{center}
		\input{fig/fa_exec.tikz}
	\end{center}
	\caption{High level overview of Forester program analysis.}
	\label{fig:fa_exec}
\end{figure}

Conceptual design of the Forester tool is shown in Figure \ref{fig:fa_design}.

\begin{figure}[bt]
	\begin{center}
		\input{fig/fa_design.tikz}
	\end{center}
	\caption{Conceptual design of the Forester tool.}
	\label{fig:fa_design}
\end{figure}


\section{Forester with VATA}
\label{sec:fova}

\subsection{Adapter design pattern}

\chapter{??Predicate Abstraction and Backward Run??}
\label{ch:pred}

\chapter{Backward Run in Forest Automata Based Verification}
\label{ch:backward}

\section{Backward Run over Symbolic Context}

\section{Intersection of Forest Automata}

\chapter{Implementation}
\label{ch:impl}

\section{Execution Trace}
\section{Module For Intersection}

\chapter{Evaluation}
\label{ch:eval}

\chapter{Conclusion}
\label{ch:concl}
