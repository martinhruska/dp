\chapter{Introduction}
In last few decades importance of computers in our everyday lifes has laregly increased.
A lot of us can only hardly imagine doing their jobs without help of appropriate computer program
and we also spend a plenty of time using computers (e.g. personal computers or mobile devices) in leisure time.
There is also wide usage of computers in more critical applications like autopilot in an aeroplane
or programs for controlling power stations.
But growing number of applications of computer programs brings also need for their safety and security.

However, guarantee of software quality and correctness is not easy task
because programs has often many state which they go through during computation
and it could be very time and (memory) space demanding to check whether no undesirable thing
happens in any of the visited states.
One approach to ensure software qaulity is \emph{testing} (and dynamic analysis) which is basically based
on runnig a program in the different contexts and under the different inputs
and checking whether programs behaviour and outputs are expected one.
This method can satisfy many of requiremnts for software quality and often cover greate space of programs behaviours
but on the other side it is only possbile to prove presence of the errors using testing not their absence (\cite{djikstra}).
Moreover finding errors during testing does not mean that all of them has been found.

The mentioned weakness of testing can be resolved by \emph{formal verification}
which is another approach to checking program correctness.
Formal verification is method for checking whether a given system meets a given specification \cite{fav:lecture}.
There are three main branches of formal verification.
The first one is \emph{model checking} which systematically explores of a model (e.g. model of a program) to
prove that a property holds along the whole model.
The second approach is static analysis which is done over a source code (or some modification of it) of a system
without its explicit execution.
The last one is \emph{theorem proving}.
It proves the program in standard mathematical way -- starting from axioms and proving theorems to
verify the properties of a given system.
Theorem proving could be more or less automated.

This thesis deals with specific part of static analysis called shape analysis which is focused to verification of the programs manipulating
complex data structures (like a different kinds of lists and trees) allocated on the heap.
The properties checked for this class of programs are for example checking whether no dangling
pointers are dereferenced (no invalid dereference), whether all allocated memory on a heap is also freed (no memory leaks)
a program exuction or whether there is not dealocated pointer which has not have assigned memory (no invalid free).
There are different approaches to this kind of static analysis with the different advantages.
For example approach based on \emph{seperation logic} brings scalability to a verification procedure.
On the other side, automata based approach, conceretly \emph{abstract tree regular model checking}, is
superior in flexibility.
However, this theisis will be focused to a verification procedure employing concept of Forest automata (FA) which tries
to synthetize benefits of the mentioned approaches.

Forest automata has been introduce in \cite{forester} and they are extension of finite automata or more precisly finite tree automata.
They are used as abstract domain in this verification procedure.
Basically, the verification procudere based on FA is perforing symbolic execution of a verified program and
FA serves here as the abstract domain.
A prototype of this verification procedure has been implemented in tool called \emph{Forester}.
Forester verifies programs in language C and it can detect invalid dereferences, invalid free, memory leaks and also reachability of an error label.
It is yet able to verify non-trivial data structures like skiplist of the second and the third level
but there is still room for improvement, e.g. by extending support of C language.

The main topic of this topic is improvement of Forester tool.
Since FA are highly related to finite tree automata (TA) the first of goal is to connect
Forester with VATA library -- state-of-the-art library for TA manipulation \cite{tacas12}.
Particulary, this consists creating of an interface between Forester and VATA to employ VATA as TA library for Forester backend.
The second goal of this thesis is to implement \emph{backward run} for Forester what enables checking spuriousness of an error found in program.
The error could be spurous because of used to high abstraction over FA domain but the information get by backward could be used for refinment of \emph{predicate abstraction}
what is one kind of abstraction used in Forester (another one is \emph{height abstraction}.
It was also not possible to fully test predicate abstraction because of absence of backward run implementation
so a part of this goal is to complete and test implementation of predicate abstraction.

A structure of this theisi will be following.
In Chapter \ref{ch:prel} will be given definitions of preliminaries for further text.
Chapter \ref{ch:tools} provides description of VATA library and Forester tool.
General principle of backward run and predicate abstract is given in Chapter \label{ch:pred} and their
application for verification based on FA is described in Chapter \label{ch:backwar}.
Chapter \ref{ch:impl} provides description of implementation and finally Chapter \ref{ch:eval} is about evalutation.
\cite{Knuth}

\chapter{Preliminaries}
\label{ch:prel}

\section{Graphs and Languages}
\section{Tree Automata}
\section{Forest Automata}

\chapter{Forest Automata based Verification}
\label{ch:fav}

\chapter{\vata\ and Forester}
\label{ch:tools}

As it was mentioned in introduction, FA based verification is implemented by tool
called Forester.
Since the FA are closely related to TA as it was shown in Chapter \ref{ch:prel} so
Forester also depends on an implementation of TA.
It currently has its own implementation of TA providing operations over TA needed during verification procedure.
However it is quite impratical to mantain a special TA library inside of Forester
and it would be more practical to employ some existing efficient TA library.
One very efficient library is the VATA library which provides implementation of standard operations over TA like union or intersection
but it also implements state-of-the-art algorithms \cite{tacas11} for language inclusion checking which efficiency
is also crucial for performance of Forester.
It seems logical according to these facts to connect Forester with the VATA library employing VATA like a backend TA library for Forester.

This chapter will provide a description of the VATA library firstly and then also a description of Forester.
Finally the implementation of Forester using VATA library done as a part of this thesis will be described.

\section{\vata}
\label{sec:VATA}

\vata\ is open source library for nondeterministic tree automata.
Its main application is in the field of formal verification.
VATA is licensed under GPL, version 3, and can be obtained from its official website \cite{www:vata}.
Implentation programming language is C++.
It is the only library to our knowledge implementing state-of-the algorithms for checking inclusion of NTA languages
what makes it suitable for usage as a Forester backend library.
However, \vata\ does not only provide implementation of algorithms for NTA but also highly efficient implementation of
algorithms for nondeterministic finite automata \cite{hruska13}.

\subsection{Design}
\vata\ currently provides methods for representation of NTA in explicit encoding and also in semi-symbolic (top-down and bottom-up)
encoding using \emph{MTBDD} but it has been designed to be easy extended by other encodings (for others automata).
The library provides both API for creating and manipulating NTA to other programs and also command line interface (cli) build around
the API for experimenting with tree automata in text format directly from command line.
The main idea of the design of the library is given in Figure \ref{fig:vata}.
As you can see there are the three main parts in the library design:
\begin{enumerate}
	\item \emph{Parsers} -- Parsing an input automaton from a text file.
		Timbuk \cite{timbuk} is currently the only one supported format for parsing input automata.
	\item \emph{Serializers} -- Serializing an automaton to a text file.
		Timbuk format is again the only one supported format.
	\item \emph{Automata encodings} -- The particular encodings of NTA.
		An encoding should consists of core module implementing of NTA representation itself
		and also the operations over NTA in this encoding.
\end{enumerate}

\begin{figure}[bt]
\begin{center}
\input{fig/lib_design.tikz}
		\caption{The main concept of \vata. Figure is taken from \cite{tacas12}}.
		\label{fig:vata}
\end{center}
\end{figure}

A \emph{program} (e.g. cli of VATA is such a program) employing the three parts of \vata\ could works as follows.
An input automaton is loaded by one of the parsers to an intermediate representation.
The wrapping program chooses internal encoding of NTA to which is automaton stored from intermediate encoding (please note that it is also
create automaton in the chosen enconding directly using API provided by VATA).
Then the automaton is processed and the applied operations are implemented by module of the chosen encoding.
Finally, automaton could be serialized to an output format.
When one wants to add her own encoding then she needs to implement only core of encoding (with API for creating automaton itself)
and ofcourse needed operations and can employ already implemented parses and serializers of \vata.

\subsection{Implemented NTA encodings}

Using \emph{explicit enconding} NTA transition relation is represented by a hiearchy of the hash tables as it is shown in Figure \ref{fig:explnta}.
The first level of the hash tables hiearchy (\emph{top-level lookup tables}) maps each state $q$ of an automaton to 
a second level of the hash tables hiearchy (\emph{transition cluster}) where are store all symbols which
are presented in a transition where $q$ is at left-handed side.
Each symbol $a$ in a transition cluster is mapped to a pointer to a set in the third level of hiearchy (\emph{sets of pointers to tuples}).
The set contains pointers to tuples which are at right-handed side in a transition with $q$ at left-handed side and with $a$ as a symbol.
The tuples are stored at a special set where every tuples is stored only once.
Please note, that it also possible to share part of transition relation between different automata what
brings higher efficiency in space complexity of implementation.
Module for explicit encoding also stores explicitly set of the final states of a NFA but on
the other side it does not store anywhere explicitly set of states because it can be obtained from a transition relation.

\begin{figure}[bt]
\begin{center}
\input{fig/explicit.tikz}
	\caption{Explicit representation of NTA by \vata. Figure is taken from \cite{tacas12}}.
	\label{fig:explnta}
\end{center}
\end{figure}

\begingroup
\tikzset{every picture/.style={scale=0.8}}%
\begin{figure}[bt]
\label{fig:symnta}
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\input{fig/mtbdd_td.tikz}
		\caption{MTBDD Top-down representation of a NTA. Image is taken from \cite{tacas12}.}
		\label{fig:mtbdd_td}
	\end{subfigure}%
	~
	\begin{subfigure}{.5\textwidth}
	\centering
	\input{fig/mtbdd_bu.tikz}
	\caption{MTBDD Bottom-up representation of a NTA. Image is taken from \cite{tacas12}.}
	\label{fig:mtbdd_bu}
	\end{subfigure}%
\end{figure}
\endgroup

Another already implemented encoding is semi-symbolic based on VATA own implementation of MTBDD package.
This encoding is efficient mainly for TA with large alphabet.
Because semi-symblic encoding and MTBDD are not in the aim of this thesis the will no be detaily described
but it is possbile to find such kind of description in \cite{lengal10}.
The main idea of semi-symbolic encoding is shown in Figure \ref{fig:symnta}.
First of all it is necessary to distinguish between (a) top-down and (b) bottom-up variants of this encoding.
The first one maps each state $q$ of a NTA using MTBDD to the sets of the tuples of states such that that it is possible
to make transtion from $q$ under a symbol $a$ to a tuple in apropriate set (each set of tuples is dedicated
to one symbol under which it is possible to make transition from $q$ to the tuples in the set).
The former one symetrically maps each n-tuple $(q_1,\ldots,q_n)$ of a NFA using MTBDD to the sets of states
where each set $S$ is dedicated to a symbol $a$ of the NFA and contains states such that there exists a transition
with $(q_1,\ldots,q_n)$ on the right-handed side and symbol $a$ and state from the set $S$ on the left-handed side.
The final state set of a NTA is again represented by explicit set in both variants,
state set is not stored explicitly because one can obtain it from transition relation and
the symbols are encoded (as binary strings) in MTBDD.

All of the mentioned encodings currently support efficient language inclusion checking using algorithm
from \cite{tacas10} but this does not hold for other operations because some of them are not implemented yet for specific encoding.
The full enumeration of the supported operations for the particular encodings is given in Table \ref{tab:vataop}.

\input{tab/vataop.tex}

\section{Forester}
\label{sec:FA}

Forester is open source tool for verification of program manipulation complex dynamic data structures.
It currently supports program in C langauge.
Forester is distributed as a \emph{GCC} plugin under GPL license, version 3, and can be obtained from its official websice \cite{www.:forester}.
Tool is written in C++.

\subsection{Design}

Forester is implemented as a GCC plugin but it does not analyze directly intermediate code of GCC called GIMPLE but is
uses Code Listener infrastructure \cite{codelistnere} to provide fronted over GIMPLE.

To get high level overiview of verification process performed by Forester please see Figure \ref{fig:fa_exec}. 
Forester starts analysis of a program by translation of intermediate code representation provided by Code Listenter
to its own microcode.
Microcode represents each program statement by one or few instruction which are indeed abstract transformers.
Symbolic execution is then execute over this microcode.
Abstract domain represented by TA as the core part of symbolic state is gradually transformed by abstract transformers
represented by the microcode instructions during the symbolic execution.
When Forester detects an error the symbolic execution is aborted and the analyzed program is determined as incorrect one.
When symbolic execution is over Forester checks whether there is no left garbage (ofcourse, garbage is gradually checked also during the symbolic exection)
and if it is not then a shape invariat has been found and the analyzed program is determined as correct.

\begin{figure}[bt]
	\begin{center}
		\input{fig/fa_exec.tikz}
	\end{center}
	\caption{High level overview of Forester program analysis.}
	\label{fig:fa_exec}
\end{figure}

A little deeper description of conceptual design of Forester (which is shown in Figure \ref{fig:fa_design}) and relations
betweeen its modules will be given now.
Please note that implementation of Forester is not explicitly seprated to the stand-alone compilation modules so the notion of the modules
used in following text is more abstract to provide reader just basic summary of the Forester design.
One module could be e.g. set of closely related classes with a similiar purpose.
As it was mentiond above Code Listener representation of GCC intermediate code is mainly used by Forester \emph{Compiler} module.
Compiler then needs to know \emph{Microcode Instructions} to be able to create their list to run \emph{Symbolic Execution} over it.
Symbolic execcution then execute microcode instructions (abstract transformers) which manipulates \emph{Symbolic State} and of course
also \emph{Forest Automata} included in symbolic states.
Symbolic exection also need \emph{Symbol Context} which is created for each function (and also for global space)
and keeps information about variables used in the function, about function arguments or about stack frame layout.
Symbolic state provides information about state of heap which is represented by FA and it also keeps the information about
corresponding microcode instruction.
\emph{Forest Automata} module provides methods for manipulation FA need during verification procedure.
The operations like normalization or abstraction over FA are not part of module implementing FA implementation but are provided
like stand alone classes which takes FA as parameters.
These operation could be understanded like anothe module \emph{Operation over Forest Automata}.
Finally, Forester currently has its own implementation of \emph{Tree Automata}.
It is very lightweighted implementation containing optimized operations like language inclusion checking using simulation needed for (efficient) Forester run.
The advantage of this implementation is its simplicity and optimization in operation hardly exploited by Forester what makes verification run shorter.
On the other side, it is not easy to mantain such a optimized implementation when one consider that there are still progress in field of design of efficent algorithms
for TA which could bring much higher efficiency then implementation optimization.
\begin{figure}[bt]
	\begin{center}
		\input{fig/fa_design.tikz}
	\end{center}
	\caption{Conceptual design of Forester.}
	\label{fig:fa_design}
\end{figure}

Please note, that is just concptual high level view of design Forester.
A real implementaion is much more complicated (e.g. Forest automata are implemented by two classes: \emph{FA} and \emph{FAE})
and full technical details.
A full description of the implementation is also not aim of this text and it is not
also possible due to size which could such documentation take.

It was already mentioned that substitution of Forester TA implementation by
VATA could bring some advanteges.
We will summarize them here again.
The first one is fact that it is much easier to maintain one library where
the state-of-the-art algorithms will be implemented and optimized.
Since VATA and Forester is developed by the same developers it also easy to added
to \vata\ operations needed by Forester.
Having narrow interface between TA library and the rest of Forester implementation
also improves code quiality of Forester in the sense of modularity, maintenability and code organization.
These arguments lead us to implement a version of Forester using the VATA library what will be described in chapter \ref{ch:fova}.

\chapter{Forester with VATA}
\label{sec:fova}

This chapter describes process of porting Forester to \vata, its difficulties and design and also deals with implementation
itself.

First of all it is important to declare that we use \vata implementation of explicit encoding of TA because
it is currently the one that support the most of neeeded operations over TA and it is also more efficient than
semi-symbolic encoding for purposes of Forester because no large alphabets are used during verification procedure
so the advantage of the semi-symbolic encoding would not be fully utillizied here.

Forester implementation is currently far from being mature and high structural dependency is
one of its bottlenecks.
So the first thing needed to be done is reducing number of dependencies between classes (described in Section \ref{sec:forester_prep}.
Then it is would be possible to apply design pattern \emph{adapter} \cite{gamma} (described in Section \ref{sec:adapter} to create
interface between Forester and \vata (final implementation described in \ref{sec:fova_impl}.
Applying of adapter design pattern makes possible to include VATA without need of rewriting
Forester to the names of methods and data used in VATA.
It is also creates one place (particularry adapter class) connecting Forester and VATA instead of
including VATA into many of the Forester classes and so it prevents from creating to strong relation between them.

\section{Forester refactoring}
\label{sec:forester_prep}

As it was mentioned there are strong dependencies between classes in Forester implementation.
The original implementation of tree automata library has not been exception so it was needed
to refactore implementation before it would be possible to create adapter clas for \vata API.
The core class of original tree automata is class \emph{TA} and there are also related classes,
e.g. class \emph{TT} for transitions representation or class \emph{Antichain} language inclusion checking using the Antichain algorithm.
This set of classes realizing original tree automata library will be further refered as tree automata module.

The refactoring is mainly based on reduction of the number data types and data members declared
to be \emph{public} (in sense of C++ language).
This is by exploiting features provided by standard C++11 \cite{c++11} which provides methods (keyword \emph{auto})
for auto deduction of the data types by compiler what makes possible to make some of data types of the original tree automata module.
\emph{Iterator} is another concept often used in combination with auto deduction of types to reduce need to export internals of tree automata module.
The combination of these two patterns have been used for example when one needs to iterate over all transitions of tree automata or all transition with some
state as parent.
Another part of refactoring consists simple replacing access of the class data members by corresponding getters and setters method.
Reducing of structural dependencies is also done by emphasis application of \emph{Law of Demeter} \cite{something} what practically
means that classes using TA explicitly should implement methods providing information about TA instead of providing object representing TA itself.
E.g. when one class wants to know whether a given state is final in an tree automaton of an forest automaton then FA implementation should
implement a method instead of providing access to its TA.
Applying the Law of Demeter reduces knowledge needed about implementation of TA module across the whole project what
helps us to make little interface for TA module.
However, Forester coding base is also after this refactoring far from accomplishing mentioned good practice (and also many not mentioned) all around the code.

\section{Adapter design pattern}
\label{sec:adapter}

\emph{Adapter} is structural design patter \cite{gamma} used for creating interface between classes incompatible classes.
Adapter in notion of UML is shown in Figure \ref{fig:adapter}.
Adapter consists from a class \emph{Adaptee} what is the class that we want to make compatible with
another class \emph{Client} which wants to use the methods of Adaptee.
Class \emph{Adaptor} is the one providing connection between Client and Adaptee.
Adaptor could be implemented as inhereted class from Adaptee and employes concept of inheritence to redirect
method calls to its parent (with some possible preprocessing).
Another possible implementation is composing Adaptee to Adaptor and using Adaptor like interface to Adaptee.
Adaptor also could add a new method that combines Adaptee methods to achieve wanted operations.

\begin{figure}
	\begin{center}
		\includegraphics[scale=0.5]{fig/adapter.png}
	\end{center}
	\caption{Adapter design pattern expressed in UML.
	Picture is taken from \cite{wikihttp://en.wikipedia.org/wiki/Adapter_pattern}}
	\label{fig:adapter}
\end{figure}

Let show what are the mentioned roles in our case.
Adaptee is API of \vata, specifically it is class \emph{ExplicitTreeAut} representing a tree automaton in explicit encoding.
Client is not in our case just one class but it is a set of the Forester classes using somehow TA library
and Adaptor is newly implemented class \emph{VATAAdapter} which description is in the following section.

\section{Implementation}
\label{sec:fova_impl}

The main part of adapter design patter is in our case newly implemented class \emph{VATAAdapter} playing role of Adaptor.
We decided to used the implementation approach to Adapter preffering composition over inheritence
because it is more suitable for our purposes since we often needs to rename methods 
(name of a method in Forester differs with name of a method in VATA performing same operation)
or conversion of paremeters data type (e.g. from vector to set). 

So class \emph{VATAAdapter} instantiates class \emph{ExplicitTreeAut} from VATA as its private data member
and redirect to this instance method calls from Forester (the names of methods of VATAAdapter are the same as they were
in the original TA library).
\emph{VATAAdapter} also sometimes performs mentioned data types conversion.
There are also methods implemented by adapter not presented in VATA like method \emph{unfoldAtRoot}
performing some kind of an unfolding.
The methods of this kind are very Forester specific so it is not sensible to add them to general purpose library like \vata is.

We initialy supposed that it will be possible to keep the original TA module with VATA library
to be able easily switch between them.
However it has proved that this would bring high overhead in some sitatuin when a conversion of some data types is needed
compared to situation when there are used directly data types compatible with \vata in Forester code
so we decided to remove the original tree automata module and further support only version of Forester with \vata.

\chapter{template$<$class Text$>$ Backward Run in Forest Automata Based Verification(Text text)}
\label{ch:backward}
text

\section{Backward Run over Symbolic Context}

\section{Intersection of Forest Automata}

\chapter{template$<$class Text$>$ Implementation(Text text)}
\label{ch:impl}
text

\section{Execution Trace}
\section{Module For Intersection}

\chapter{template$<$class Text$>$ Evaluation(Text text)}
\label{ch:eval}
text

\chapter{template$<$class Text$>$ Conclusion(Text text)}
\label{ch:concl}
text
