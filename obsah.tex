\chapter{Introduction}
In last few decades importance of computers in our everyday lifes has laregly increased.
A lot of us can only hardly imagine doing their jobs without help of appropriate computer program
and we also spend a plenty of time using computers (e.g. personal computers or mobile devices) in leisure time.
There is also wide usage of computers in more critical applications like autopilot in an aeroplane
or programs for controlling power stations.
But growing number of applications of computer programs brings also need for their safety and security.

However, guarantee of software quality and correctness is not easy task
because programs has often many state which they go through during computation
and it could be very time and (memory) space demanding to check whether no undesirable thing
happens in any of the visited states.
One approach to ensure software qaulity is \emph{testing} (and dynamic analysis) which is basically based
on runnig a program in the different contexts and under the different inputs
and checking whether programs behaviour and outputs are expected one.
This method can satisfy many of requiremnts for software quality and often cover greate space of programs behaviours
but on the other side it is only possbile to prove presence of the errors using testing not their absence (\cite{djikstra}).
Moreover finding errors during testing does not mean that all of them has been found.

The mentioned weakness of testing can be resolved by \emph{formal verification}
which is another approach to checking program correctness.
Formal verification is method for checking whether a given system meets a given specification \cite{fav:lecture}.
There are three main branches of formal verification.
The first one is \emph{model checking} which systematically explores of a model (e.g. model of a program) to
prove that a property holds along the whole model.
The second approach is static analysis which is done over a source code (or some modification of it) of a system
without its explicit execution.
The last one is \emph{theorem proving}.
It proves the program in standard mathematical way -- starting from axioms and proving theorems to
verify the properties of a given system.
Theorem proving could be more or less automated.

This thesis deals with specific part of static analysis focused on verification of the programs manipulating
complex data structures (like a different kinds of lists and trees) allocated on the heap.
The properties checked for this class of programs are for example checking whether no dangling
pointers are dereferenced (no invalid dereference), whether all allocated memory on a heap is also freed (no memory leaks)
a program exuction or whether there is not dealocated pointer which has not have assigned memory (no invalid free).
There are different approaches to this kind of static analysis.
One approach is based on separation logic (some citations here) which has yet some successful implementation \cite{predator} which has been
evaluated on SV-Comp benchmark \cite{svcomp}.
Another approach is automata based, more precisly based on concept of \emph{Forest automata} and this one
will be main topic of this thesis.

The Forest automata has been introduced in \cite{forester} and implemented in tool called \emph{Forester} (appeared on SV-Comp 15).


\cite{Knuth}

formal verification

complex data structure and memory safety

forester and vata

outline

\chapter{Preliminaries}

\section{Graphs and Languages}
\section{Tree Automata}
\section{Forest Automata}

\chapter{VATA and Forester}

\section{VATA}

\section{Forester}

\section{Other Tools}

\chapter{??Predicate Abstraction and Backward Run??}

\chapter{Backward Run in Forest Automata Based Verification}

\section{Backward Run in Symbolic Context}

\section{Intersection of Forest Automata}

\chapter{Implementation}

\section{Execution Trace}
\section{Module For Intersection}

\chapter{Evaluation}

\chapter{Conclusion}
